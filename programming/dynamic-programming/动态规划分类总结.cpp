# 动态规划问题总结

## 1. 爬楼梯
dp[i] = dp[i-1] + dp[i-2] 等其他变种, 当前i位置从哪个地方来
- 70
- 746
- 377
- 2466 

## 2.打家劫舍
相邻位置不能选择

dp[i] = max(dp[i-1], dp[i-2] + nums[i])

- 198
- 213  变种，考虑第一个位置选不选转换成198问题
- 2320 dp[i] = dp[i-1] + dp[i-2]
- 740  值域打家劫舍
- 3186 值域打家劫舍, 使用哈希表
- 2140 从右往左进行递推

## 3.最大子数组和
子数组 & 子串等想到 dp[i] 以当前i结尾的最大子数组和
- 53 : dp[i] = max(dp[i-1] + nums[i], nums[i])
- 2606 dp[i] = max(dp[i-1] + nums[i], nums[i])
- 1749 : 同时保留最大和最小值，然后比较
- 1191 : 变种，k=1, k=2, k > 2然后讨论即可
- 918 : 同时保留最大和最小值
- 2321: sum = \sums  s + diff 转成diff数组求解最大子数组和

- 152 : 最大乘积子数组， 注意负数的影响，当存在负数时，对最大和最小进行交换
- 1186 : https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/

## 4.网格图dp


## 5.背包问题
存在问题f[j] = f[j] || f[j-num];
组合问题: dp[i] = dp[i] + dp[i-num];
最值问题: dp[j] = min(dp[j], dp[j-coin]+1);

- 01背包: 416
- 完全背包 322, 279


# 6.最长公共子序列
- 1143 dp[i][j] s[:i],t[:j]的最长公共子序列
- 583 等价求最长公共子序列
- 712
- 1035
- 1458 不同的是四种情况
- 718 : 注意和最长公共子序列的区别在哪
- 115

# 7.最长递增子序列
- 300 : 贪心+二分
- 2826
- 1671: dp[i] 以i结尾的最长递增子序列
- 1964
- 2111


# 8.划分型dp
- 2369
- 139 
- 132
- 2707 dp[i] i位置最小，选或不选





other:

0005.最长回文子串: dp[i][j] 表示 s[i, j] 是否是回文串, dp[i][j] = s[i] == s[j] && (j - i < 3 || dp[i + 1][j - 1])